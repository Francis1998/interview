## 1.算法：维护第二大的值

遍历一遍，n，保留max和第二大的max

## 2.Go Select 优先级问题（通过default）

## 3.算法题：从后向前每k个节点做一个反转，若剩余不足k个，则不用反转(leetcode27)

先 k反转的实现，图模拟，然后再写整体的

## 4.算法题：判断树是否是对称的

层次遍历 l.r,r.l

## 5.栈实现O(1)获得最小的数getMin()

辅助栈、小的入

## 6.智力题 有1000个一模一样的瓶子，其中有999瓶是普通的水，有1瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有10只小白鼠和一星期的时间，如何检验出那个瓶子里有毒药？

二进制，2**10 = 1024 1死2死3死则是7号(111)有毒

## 7.确认链表是否有环

双指针，快慢；

8. 口述快排，什么时候是n2（每次有一部分是空的）什么时候是nlogn（pivot对半开）

9. 二分查找

10. Rand3实现rand5,rand5实现rand3

Def rand3():大的实现小的       def rand5(): 小的实现大的

X = -1                              x = sys.maxsize

While not 0<=x<3:                       while x>5:

X = rand5()                              3(rand3 - 1) + rand3

Return x                                return x

11. 5个海盗分配100个金币，从一号开始分配，要是没有50%的人满意，按顺序丢水里，重新分配，怎么分配，1号保证不死？

45：0 100

345：100 0 0 (or 99 1 0)

2345：98 0 1 1(or 97 0 2 1)

12345: 97 0 1( 98 0 1 0 1 or 97 0 1 0 2)

12. 硬中断和软中断(硬中断是外设引发的，软中断是执行中断指令产生的，用来处理硬中断中时间较长的工作)

13. 操作系统中Kernel Mode和User Mode的区别（CPU处于KM，任务可以执行特权级指令，对I/O设备有全部的访问权，能访问任何虚拟地址和控制虚拟内存硬件。CPU处于UM，硬件防止特权指令的执行，对内存和I/0空间的访问操作进行检查。如运行的代码不能通过os的某种门机制，就不能进入内核模式）

\14. 海量数据，前K（分而治之/映射+hash统计+堆排序/快速/归并）；海量数据，不重复（2bitmap，00、01、10、11）or重复的数据(bitmap)；找中位数(分治：遍历，hash划分，统计个数直到k个；去到该机器中，排序找到n**2/2-x)

\15. Go语言的特点：1.底层使用goroutine作为并发实体，每个实体之间通过channel通讯来实现数据共享，将并发单元间的数据耦合拆解开。2.goroutine底层是使用协程(运行在用户态的用户线程)实现并发，用户空间、避免了内核态和用户态的相互切换，更小的栈空间能创建大量的实例3. 充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上4.标准库完善5.代码简洁6.性能强劲的同时，开发效率又不差于Python等动态语言

\16. TCP和UDP的区别(1.TCP面向连接udp无连接2.tcp提供可靠服务，udp不保证可靠3.tcp面向字节流，udp面向报文4.tcp有拥塞控制，udp无，UDP的性能收到网络层的影响很大，当网络层的状况比较好的时候，UDP的性能远远高于TCP，但是当网络层的情况不好时，UDP反而会使网络状况越来越差5.tcp只能点到点，udp支持一对一、一对多、多对一、多对多的交互通信6.tcp首部开销大20字节，udp8字节) 

\17. TCP三次握手和四次挥手过程(

https://blog.csdn.net/qq_38950316/article/details/81087809

1、第一次握手，客户端发生SYN包(seq = x)到服务器，进入syn_sent状态，等待服务器确认

2、第二次握手，服务器收到syn包，必须确认客户的SYN(ack=x+1)，同时自己也发送SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态

3、第三次握手，客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完成，客户端和服务器进入established状态，完成三次握手

四次

1、第一次挥手，客户端发送连接释放报文，停止数据发送，释放数据报文首部，FIN =1, seq = u（==前面已经传送过来的数据的最后一个字节的序号+1)，客户端进入，FIN-WAIT-1

2、第二次挥手，服务器收到连接释放报文，发出确认报文，ACK = 1，ack=u+1，seq=v，服务器进入close-wait状态。tcp服务器通知高层应用，客户端向服务器端的方向释放，处于半关闭的状态。

3、客户端在收到服务器端的确认请求后，客户端进入FIN-WAIT-2状态，等待服务器发送释放报文(FIN)

4、第三次挥手，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ACK=1, ack = u + 1，seq = w，服务器进入last-ack

5、第四次挥手，客户端收到服务器的连接释放报文，必须发出确认，ACK = 1, ack = w+1，seq = u+1，客户端进入了TIME-WAIT状态，经过2msl后，客户端撤销响应的TCB后，进入closed状态

6、Server收到确认，立即进入closed状态。

)

\18. http 1.0和1.1的区别（1.0 默认短，支持长，需要设置header **connection: kepp_Alive** 1.1默认长 ）

\19. 四次挥手的状态

Closed；收到ack；close-wait；server数据发送完，发送FIN；last-ack；收到ACK；closed

\20. 为什么连接的时候是三次握手，关闭的时候却是四次握手？

当server收到client的SYN连接请求时，可以直接发送SYN+ACK报文。但是关闭的时候，server收到FIN，很可能不会立即关闭socket，所以只能先回复一个ACK报文。只有server端所有报文发送完了，才发送FIN报文。

\21. 为什么不能用两次握手进行连接？

三次握手作用：1、双方彼此知道都已经准备好了2、就初始序列号协商。若两次，服务器发送的确认有可能丢失，服务器端认为已经成功，client将不知道S是否准备好，S的序列号是什么。且会死锁，client一直等待ACK。Server也超时重传一样的分组。

\22. 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP有一个保活计数器，每次收到client都会复位，2h，2h没收到，发送探测报文段，每隔75s发送一次，一连发10个无反应，断开。

\23. time_wait大量出现的原因（socket忙于读写或者程序忘了没有close、爬虫服务器）？如何避免这种问题？（两种解决方案：基于socket调用close；基于TCP连接的参数设置，连接超时设置或者按照一定的频率监控连接是否活动，没有活动就关闭连接。1、让服务器能够快速回收和重用那些TIME_WAIT的资源，内核参数优化/etc/sysctl.conf）

24.

Mysql

聚集索引：逻辑和物理结构相同

非聚集：逻辑和物理结构不相同

Innodb engine 还行级锁（通过索引实现），支持事务，支持外键(CONSTRAINT `xiaodi_ibfk_1` FOREIGN KEY (`dage_id`) REFERENCES `dage` (`id`),保证数据一致性，和一些级联操作)、（聚集索引、主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键）

Myisam非聚集索引

四种事务隔离级别：1. 读未提交(事务未提交时，另一个事务可) 2. 读已提交(只能读已提交数据，解决脏读)3. 可重复读(一个事务内多次读取，数据都是一致的。解决了脏读、不可重复读)4. 序列化(事务串行执行，解决脏读、不可重复读、幻读)

不良反应：脏读、不可重复读(事务所读取的数据值变了)、幻读(类似前者，但是是再次读取时插入数量变了，**事务****A****按照一定条件读取，读取期间事务B****插入了相同搜索条件的新数据，事务A****再次按照原先条件进行读取时，发现了事务B****新插入的数据**)、丢失修改(两事务同时对数据库做相同的修改，读的值相同，操作相同，前面的事务的修改被覆盖)

\25. HTTP方法

Post 不幂等 升级用这个、有新的事务产生

Put 幂等 停止用这个

26.实例可以比较吗？

实例不可比较，实例是指针

27.

Var a int

typeofA := reflect.TypeOf(a)

aInstance := reflect.New(typeofA)

Goroutine本质是协程，协程之间的调度由程序底层完成(线程和进程的调度是sys)，协程有自己的寄存器上下文和栈，切换时将两者保存到。

Go defer栈先进后出

Select底下有多个可执行的case，则随机执行一个。

无缓冲chanel：传值立马close

\1. Linux指令，怎么查看内存线程使用情况

top -Hp pid

\2. Mysql union和union all

Union 把两个查询结果去重合并 all则不去重（第一个 SELECT 语句中被使用的字段名称也被用于结果的字段名称、各 SELECT 语句字段名称可以不同，但字段属性必须一致）

\3. Mysql groupby

GROUP BY 语句根据一个或多个列对结果集进行分组

\4. 四次挥手，为什么等待2MSL(time-wait)?

4.1 为了保证 客户端最后一个ACK能送到服务器。ACK可能丢失，当处在last-ack的服务器没有收到对已发送的FIN+ACK报文段的确认，就会超时重传，A就能在2msl内收到这个重传的FIN+ACK的报文段。如果客户端在time-wait不等待，发完ack就立即释放，就收不到重传的fin-ack，也不会再一次发送ack。服务器就无法按正常步骤进入closed状态

4.2 客户端发完最后一次ack，等2msl，可以让本连接持续时间产生的所有报文段从网络中消失。下一个新连接中不会出现旧的连接请求报文段，迷路后重新出现。

 

http400

（1）前端提交的字段名称或者字段类型和后台的实体类不一样 或者前端提交的参数跟后台需要的参数个数不一致，导致无法封装

（2）前端提交到后台的数据应该是JSON字符串类型，而前端没有将对象转化为字符串类型；

解决方法： 对照字段名称，类型保证一致

 

 

http和https的区别

1.https需要到ca申请证书2.http的信息明文传输，https具有安全性的ssl加密传输协议3.使用端口不同，http80https443 4.http连接简单，无状态5.https 由ssl+http协议构建的加密传输、身份认证的网络协议。

 

mysql 三个范式

\1. 属性的原子性（没列不可再分）2.记录的唯一性，说明一个事务。属性必须完全依赖主键，不存在部分依赖3.字段的冗余性，非主属性不依赖于其他的非主属性
