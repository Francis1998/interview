# Python-Interview-Questions
[Python后端开发面经](#python后端开发面经)
- [语言基础与特性](#语言基础与特性)          
    - [1. type( ) 和 isinstance( )的区别](#1-type--和-isinstance-的区别)             
    - [2. 全局解释器锁GIL：Global Interpreter Lock](#2-全局解释器锁gilglobal-interpreter-lock)           
    - [3. Python内存管理](#3-python内存管理)                
    - [4. Python协程](#4-python协程)          
    - [5. Python怎么存储字符串，切片](#5-python怎么存储字符串切片) 
- [数据结构与算法](#数据结构与算法) 
    - [1. 归并排序原理阐述](#1-归并排序原理阐述)
    - [2. 快排原理阐述](#2-快排原理阐述)
    - [3. 常用查找和排序的时间复杂度](#3-常用查找和排序的时间复杂度)
    - [4. 红黑树](#4-红黑树)   
- [OS](#os)               
    - [1. 并行、并发的区别](#1-并行并发的区别) 
    - [2. 互斥锁](#2-互斥锁)
    - [3. 进程和线程的区别](#3-进程和线程的区别)
    - [4. 多进程和多线程的区别](#4-多进程和多线程的区别)
- [计算机网络](#计算机网络)
    - [1. OSI和TCP/IP模型](#1-osi和tcpip模型)
    - [2. TCP/IP各层功能](#2-tcpip各层功能)
    - [3. TCP建立连接过程（三次握手）](#3-tcp建立连接过程三次握手)
    - [4. TCP断开连接过程（四次挥手）](#4-tcp断开连接过程四次挥手)
    - [5. TCP和UDP的区别](#5-tcp和udp的区别)
- [数据库](#数据库)
    - [1. 知道几种数据库，有什么区别](#1-知道几种数据库有什么区别)
    - [2. MySQL索引, B+树和B树的区别](#2-mysql索引-b树和b树的区别)
- [业务问题](#业务问题)
    - [1. 后端开发的工作内容](#1-后端开发的工作内容)
- [HR会问的玄学问题](#hr会问的玄学问题)
- [补充](#补充)

**1.** **进程与线程的区别** 

1.1进程是os资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

1.2每个进程有独立的代码和数据空间，切换会有较大的开销；线程可以看作轻量级进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器，线程之间切换的开销小

1.3 一个进程有多个线程，线程是进程的一部分

1.4 一个进程崩溃，在保护模式下不会对其他的进程产生影响，但是一个线程崩溃，整个进程都会死掉。多进程要比多线程健壮

1.5 每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中。

**3.** **用户态和内核态，为什么要划分？内存上怎么划分的？**

 防止应用程序越权访问内存时使用了虚拟空间映射技术，在用户态下，应用程序访问的内存地址是虚拟内存地址，会映射到os的物理地址上，虚拟内存地址空间就是用户空间。

**4.** **怎么由用户态转到内核态？** 

1、系统调用(处于用户态进程的主动请求切换到内核态的。使用了软中断)2、产生异常3、外设产生中断

**5.** **用户程序使用系统调用是怎么做的，能否直接进行系统调用？**

软中断，Linux上一般是通过syscall指令进行系统调用。Go直接封装到了包里，fmt.Println调用了syscall.Write

**6.** **ISO****七层模型** **(****应用层(http/ftp)****、表示层(telnet)****、会话层(Session)DNS****、传输层tcp udp****、网络层ip arp icmp****、数据链路层、物理层)**

**7.** **https****中的ssl****层属于什么层，说一说ssl****握手的流程**

SSL协议位于TCP/IP协议与各种应用层协议之间，在运输层对网络连接进行加密。

Ssl目的1、c/s需要就一组用于保护数据的算法达成一致2、需要确立一组由那些算法所使用的加密密钥3、握手可以对client进行验证

1、c将所支持的算法列表和一个用作产生密钥的**随机数**发给服务器

2、s从算法列表中选择一种加密算法，将**它**和一份**包含服务器公用密钥的证书**发给客户端，证书还包含了用于认证目的的服务器标识，s还提供一个用于产生密钥的**随机数**

3、客户端对服务器的证书进行验证，抽取服务器的**公有密钥**；然后再产生一个pre_master_secret的**随机密码串**，并使用服务器的**公有密钥对随机密码串加密**，将加密后的信息发给s

4、客户端和服务器端根据**pre_master_secret****随机密码串**以及客户端与服务器的**随机数值**独立计算出**加密和****MAC****密钥**

5、c将所有握手信息的MAC值发给s

6、s将所有握手信息的MAC值发给c

**56****防止握手本身被篡改，c****的mac****由原始消息产生，s****可能被攻击者修改，检查匹配**

**8.** **数据库的事务acid**

**begin commit/rollback**

Atomicity（事务是一个不可分割的工作单位，事务的操作要么全部成功or失败）、consistency（事务执行前后都必须处于一致性状态）、isolation（多个并发事务相互隔离）、durabiliry（事务一旦提交，对数据的改变是永久性的） 

**13.** **设计模式**

1、单例模式（一个类只有一个实例，并提供全局访问点）

class S:

  instance = None

  def __new__(cls, *args, **kwargs):

​    if S.instance is None:

​      S.instance = super().__new__(cls)

  def __init__(self):

​    pass

2、工厂模式

1.不知道用户想要创建什么样的对象

2.当你想要创建一个可扩展的关联在**创建类**与**支持创建对象的类**之间。

class Factory:

  def getPerson(self, name, gender):

​    if gender == ‘M':

​        return Male(name)

​     if gender == 'F':

​      return Female(name)

 

3、抽象工厂模式

提供一个接口, **用于创建相关或依赖对象的家族**, 而**不需要指定具体类**。“ 工厂产生类 ”去让我们决定到底是要产生哪个类的实例。围绕一个超级工厂创建其他工厂。

class FactoryProducer:

  def get_factory(self,name):

​    if name=='Shape':

​      return ShapeFactory()

​    elif name=='Color':

​      return ColorFactory()

​    else:

​      return None

4、原型模式、多例模式

\14. Mysql语句检查：通过explain检查

\15. 进程间的通信

管道（包括无名管道（有关进程）和命名管道（无关））、消息队列、信号量（os的pv信号量用于实现进程间的互斥与同步）、共享存储、Socket(于不同机器间的进程通信)、Streams

\16. 线程间的通信

信号量、互斥量、条件变量

**17. Redis****数据过多应该怎么办** lru算法、存热点数据

**18.** **找出一堆树里面最大的Top k****，说说几种思路，复杂度各是多少**

O(N·lgK)  【N为海量数据，K为要取的最大前K个数。】

算法题：平衡二叉树

Not equal return -1

堆的时间复杂度：初始化建堆是n，调整堆是nlogn

Session是KV存储，HashMap 

**状态码403** **无权限访问**

**链表**

**链表有顺序之分，插入删除快，但是查找慢**

**19.** **Redis****单线程他会快**

Redis基于内存的操作（内存读写快）、CPU不是Redis的瓶颈，**机器内存大小或者网络带宽**才是、**单线程省去了上下文切换线程的时间、****redis****使用****IO****多路复用技术**，可以处理并发的连接。非堵塞IO 内部实现采用epoll+自己实现的简单的事件框架。epoll的读、写、关闭、连接都转化成了事件，利用epoll的多路复用特性，不在io上浪费时间。不需要各种锁（很细粒度的操作）的性能消耗、无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善

\20. **为什么多路复用会快？**

redis 采用网络IO多路复用技术来保证在多连接的时候，**系统的高吞吐量。多路：多个****socket****网络连接，复用一个线程。**同时管理多个I/O流。系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。

**21.** **poll****和****epoll****的区别？**

epoll 现在是线程安全的。epoll 现在不仅告诉你sock组里面数据，还会告诉你具体哪个sock有数据，你不用自己去找了。

Poll不是线程安全的，只能在一个线程里面处理一组I/O流。poll返回后，需要轮询pollfd来获取就绪的描述符。

select 如果任何一个sock(I/O stream)出现了数据，select 仅仅会返回，但是并不会告诉你是那个sock上有数据，于是你只能自己一个一个的遍历，且max_size = 1024。会修改传入的参数数组。不是线程安全

**22.** **说一下五种****IO****模型，以及如何区别它们？**

阻塞I/O模型（所有文件操作的阻塞的）、非阻塞I/O模型（）、.多路复用IO模型（会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作）、信号驱动IO模型（当用户线程发起IO请求操作，会给对应的socket注册一个信号函数，然后用户线程继续执行，当内核数据就绪时就发一个信息给用户线程，用户线程接收到信号时，在信号函数中调用IO读写操作进行实际的读写）、异步IO模型（IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。）

\23. redis的缓存淘汰机制？lru的实现

Lru，python 中是用ordereddict 底层是双向链表和hashmap。HashMap 的 Value 指向双向链表实现的 LRU 的 Node 节点。如果存储满了，可以通过 O(1) 的时间淘汰掉双向链表的尾部，每次新增和访问数据，都可以通过 O(1)的效率把新的节点增加到对头，或者把已经存在的节点移动到队头

\24. 面向连接和无连接的区别？

无连接协议，每个分组的处理都独立于其他的分组。面向连接的协议，协议实现维护了当前分组和后继分组有关的状态信息。应用场景不同，可靠性要求较高TCP（HTTP、FTP）、无连接的套接字(UDP服务)，效率和实时为要求，DNS

\25. 堆初始化后，堆顶与最后一个交换，然后向下筛选，将元素移动到正确的位置

Def heapify(arr,n,i):

Largest = i

L = 2i+1

R = 2i+2

if l<n and arr[l]>arr[i]:

largest = l

if r<n and arr[largest]<arr[r]:

largest = r

if largest != i:

swap(arr[largest],arr[i])

heapify(arr,n,largest)

def heapsort(arr):

n = len(arr)

for i in range(n>>1,-1,-1):

heapify(arr,n,i)

for i in range(n,0,-1):

swap(arr[i],arr[0])

heapify(arr,i,0)

**26.** **mysql****联合索引，最左匹配，****abcd****，如果要用索引，不能跳过****a****，单独用****b****。****c>4****后****,abc****字段能用索引，****d****不行，遇到了范围查询。多键值的****b+****树。区分度高的字段放在前面，区分度低的字段放后面。像性别、状态这种字段区分度就很低，我们一般放后面。**

**27.** **查看打印日志****cat -n test.log |grep "debug" >debug.txt**

**28.** **golang** **死锁展示（****wg := sync.WaitGroup;wg.Add(100)****计数器为****100****，****wg.Done()****会减一，****wg.Wait()****会阻塞，直到计数器为****0****。****sync.Mutex****当一个****goroutine****获得这个锁，其他的只能等待释放** **）**

**type value stuct{**

**mu sync.Mutex**

**value int**

**}**

**func main(){**

**var wg sync.WaitGroup**

**PrintSum:=func(v1,v2 \*value){**

**defer wg.Done()**

**v1.mu.Lock()**

**defer v1.mu.Unlock()**

**v2.mu.Lock()**

**defer v2.mu.Lock()**

**}**

**var a,b value**

**wg.Add(2)**

**go PrintSum(&a,&b)**

**go PrintSum(&b,&a)**

**wg.Wait()**

**}**

**29.** **而服务器端开发中，大多数时候都是要花大量等待时间的场景，也就是所谓的****IO****密集，协程极为适合这种场景。创建线程的开销都要大于节省下来的时间（一个线程内可有多个协程）**

**30.** **web****状态码**

**300****重定向（需要客服端采取进一步措施，后续请求地址在本次响应的****location****域中指明）**

**400** **语法错误，无法被****server****理解**

**401** **需要用户验证**

**403 server****理解请求，但是拒绝，一般是权限问题。**

**404** **请求资源没在服务器上发现**

**405** **请求方法不被允许**

**408** **请求超时**

**501** **服务器不支持当前请求需要的某种功能**

**502** **网关或者代理服务器尝试执行请求时，从上游服务器接收到无效响应**

**503** **服务器临时维护或者过载**

**504** **网关或者代理服务器尝试执行请求时，从上游服务器未及时收到响应**

**505 HTTP****版本不支持**

 

**cookie****和****session****：**

**1.****位置****2.****容量****3.****存储方式（****ascii****，****session****任何类型）****4.****隐私策略** **爬虫****5.****服务器压力**

 

 

**select** **每次调用都是线性遍历****epoll****内核是根据每个****fd****上的****callback****函数来实现，只有活跃的****socket****才会主动调用****callback****。**

 

 

**linux****命令** **查看端口使用情况****netstat -tunlp****。**

**内存使用情况，****top**

**查看内存占用最多的三个进程** **ps -aux|sort -k4nr|head -3**  

**(-k****指定第几列或第几列的第几个字符****,-n** **依照数值的大小排序****,-r** **倒序（降序）以相反的顺序来排序****)**

**查看硬盘空间大小** **df -lh**

**查看****cpu****核数** **cat /proc/cpuinfo |grep “processor”|wc -l**

**查看内存信息** **cat /proc/meminfo**

 

**Slice****与数组区别****.Slice****底层结构****Go****的反射包怎么找到对应的方法（这里忘记怎么问的，直接说不会，只用了****DeepEqual****，简单讲了****DeepEqual****）**

**https://www.jianshu.com/p/6bf41d9dcb6e**

 

**get****、****post****区别**

**1、****get****是不安全的，因为在传输过程中，数据放在****url****中。****post****所用操作对用户来说不可见****2****、****get****传送数据量小，受****url****长度限制。****post****传送数据量大**

**3、****get****限制****form****表单的数据集值为****ascii****字符，****post****支持所有****iso****字符集**

**4、****get****执行效率比****post****方法好。****get****是****form****提交的默认方式。**

 

**进程状态转化**

![jpg](H:\javawork\upload\interview\.jpg)

**哈希解决冲突****(****拉链法、开放定址法，寻找下一个空的散列地址、再****hash****，直到无冲突****)****，哈希表使用链表法时，如果链太长如何使时间降下来****(****红黑树****+****链表****)**

 

**红黑树：****1****、根节点黑****2****、叶节点黑****3****、一结点红，两儿子黑****4****、对于任一节点，到叶节点的每一条路径都包含相同数目的黑节点（牺牲严格高度平衡，降低对旋转要求，提高性能）**

 

**get****、****put****、****post****、****delete****、****update****、****trace****（请求服务器回送收到的请求信息）、****connect****、****options****（服务器性能）**

 

 硬中断和软中断(硬中断是外设引发的，软中断是执行中断指令产生的，用来处理硬中断中时间较长的工作)操作系统中Kernel Mode和User Mode的区别（CPU处于KM，任务可以执行特权级指令，对I/O设备有全部的访问权，能访问任何虚拟地址和控制虚拟内存硬件。CPU处于UM，硬件防止特权指令的执行，对内存和I/0空间的访问操作进行检查。如运行的代码不能通过os的某种门机制，就不能进入内核模式）



5、 TCP和UDP的区别(1.TCP面向连接udp无连接2.tcp提供可靠服务，udp不保证可靠3.tcp面向字节流，udp面向报文4.tcp有拥塞控制，udp无，UDP的性能收到网络层的影响很大，当网络层的状况比较好的时候，UDP的性能远远高于TCP，但是当网络层的情况不好时，UDP反而会使网络状况越来越差5.tcp只能点到点，udp支持一对一、一对多、多对一、多对多的交互通信6.tcp首部开销大20字节，udp8字节) 

\17. TCP三次握手和四次挥手过程(

https://blog.csdn.net/qq_38950316/article/details/81087809

1、第一次握手，客户端发生SYN包(seq = x)到服务器，进入syn_sent状态，等待服务器确认

2、第二次握手，服务器收到syn包，必须确认客户的SYN(ack=x+1)，同时自己也发送SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态

3、第三次握手，客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完成，客户端和服务器进入established状态，完成三次握手

四次

1、第一次挥手，客户端发送连接释放报文，停止数据发送，释放数据报文首部，FIN =1, seq = u（==前面已经传送过来的数据的最后一个字节的序号+1)，客户端进入，FIN-WAIT-1

2、第二次挥手，服务器收到连接释放报文，发出确认报文，ACK = 1，ack=u+1，seq=v，服务器进入close-wait状态。tcp服务器通知高层应用，客户端向服务器端的方向释放，处于半关闭的状态。

3、客户端在收到服务器端的确认请求后，客户端进入FIN-WAIT-2状态，等待服务器发送释放报文(FIN)

4、第三次挥手，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ACK=1, ack = u + 1，seq = w，服务器进入last-ack

5、第四次挥手，客户端收到服务器的连接释放报文，必须发出确认，ACK = 1, ack = w+1，seq = u+1，客户端进入了TIME-WAIT状态，经过2msl后，客户端撤销响应的TCB后，进入closed状态

6、Server收到确认，立即进入closed状态。

)

\18. http 1.0和1.1的区别（1.0 默认短，支持长，需要设置header **connection: kepp_Alive** 1.1默认长 ）

\19. 四次挥手的状态

Closed；收到ack；close-wait；server数据发送完，发送FIN；last-ack；收到ACK；closed

\20. 为什么连接的时候是三次握手，关闭的时候却是四次握手？

当server收到client的SYN连接请求时，可以直接发送SYN+ACK报文。但是关闭的时候，server收到FIN，很可能不会立即关闭socket，所以只能先回复一个ACK报文。只有server端所有报文发送完了，才发送FIN报文。

\21. 为什么不能用两次握手进行连接？

三次握手作用：1、双方彼此知道都已经准备好了2、就初始序列号协商。若两次，服务器发送的确认有可能丢失，服务器端认为已经成功，client将不知道S是否准备好，S的序列号是什么。且会死锁，client一直等待ACK。Server也超时重传一样的分组。

\22. 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP有一个保活计数器，每次收到client都会复位，2h，2h没收到，发送探测报文段，每隔75s发送一次，一连发10个无反应，断开。

\23. time_wait大量出现的原因（socket忙于读写或者程序忘了没有close、爬虫服务器）？如何避免这种问题？（两种解决方案：基于socket调用close；基于TCP连接的参数设置，连接超时设置或者按照一定的频率监控连接是否活动，没有活动就关闭连接。1、让服务器能够快速回收和重用那些TIME_WAIT的资源，内核参数优化/etc/sysctl.conf）

\25. HTTP方法

Post 不幂等 升级用这个、有新的事务产生

Put 幂等 停止用这个



\4. 四次挥手，为什么等待2MSL(time-wait)?

4.1 为了保证 客户端最后一个ACK能送到服务器。ACK可能丢失，当处在last-ack的服务器没有收到对已发送的FIN+ACK报文段的确认，就会超时重传，A就能在2msl内收到这个重传的FIN+ACK的报文段。如果客户端在time-wait不等待，发完ack就立即释放，就收不到重传的fin-ack，也不会再一次发送ack。服务器就无法按正常步骤进入closed状态

4.2 客户端发完最后一次ack，等2msl，可以让本连接持续时间产生的所有报文段从网络中消失。下一个新连接中不会出现旧的连接请求报文段，迷路后重新出现。

 

http400

（1）前端提交的字段名称或者字段类型和后台的实体类不一样 或者前端提交的参数跟后台需要的参数个数不一致，导致无法封装

（2）前端提交到后台的数据应该是JSON字符串类型，而前端没有将对象转化为字符串类型；

解决方法： 对照字段名称，类型保证一致

 

 

http和https的区别

1.https需要到ca申请证书2.http的信息明文传输，https具有安全性的ssl加密传输协议3.使用端口不同，http80https443 4.http连接简单，无状态5.https 由ssl+http协议构建的加密传输、身份认证的网络协议。

